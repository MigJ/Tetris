/*
** order.c for tetris in /home/detroy_j/Documents/delivery/tetris/srcs/tetriminos
** 
** Made by detroy_j
** Login   <jean-baptiste.detroyes@epitech.eu@epitech.net>
** 
** Started on  Thu Feb 23 13:07:04 2017 detroy_j
** Last update Thu Feb 23 14:55:18 2017 detroy_j
*/

#include <string.h>
#include "tetriminos.h"

/* static int	check(char *s1, char *s2)
{
  int	i;

  i = 0;
  while (s1[i] != '\0' && s2[i] != '\0')
    {
      if (s1[i] >= 'a' && s1[i] <= 'z' && s2[i] >= 'a' && s2[i] <= 'z')
	{
	  if (s1[i] == s2[i])
	    i++;
	  else if (s1[i] > s2[i])
	    {
	      return (1);
	    }
	}
      if (s1[i] > s2[i])
	return (1);
    }
  return (0);
}

int	order_ascii(t_game *game)
{
  t_tetrimino	*now;
  t_tetrimino	*tmp;
  t_tetrimino	*

  now = game->first;
  tmp = game->first->next;
  while (now != NULL && tmp != NULL)
    {
      if (check(now->name, tmp->name))
	{
	  if (now == game->first)
	    game->first = tmp;

	  tmp2 = tmp->next;
	  
	  now = game->first;
	  tmp = game->first->next;
	  continue;
	}
      now = now->next;
      tmp = tmp->next;
    }
  return (0);
}*/



int     alpha_tri(char *s1, char *s2)
{
  char  a;
  char  b;

  while (*s1 != '\0' && *s2 != '\0')
    {
      a = *s1;
      b = *s2;
      (a >= 65 && a <= 90) ? a += 32 : 0;
      (b >= 65 && b <= 90) ? b += 32 : 0;
      if (a > b)
	return (1);
      else if (*s1 == *s2)
	{
	  s1++;
	  s2++;
	}
      else
	return (0);
    }
  return (0);
}

void    swap_element(t_game *g, t_tetrimino *now, t_tetrimino *tmp)
{
  t_tetrimino        *tmp2;

  tmp2 = now->prev;
  (tmp == g->last) ? g->last = now : 0;
  (now == g->first) ? g->first = tmp : 0;
  (tmp2 != NULL) ? tmp2->next = tmp : 0;
  (tmp->next != NULL) ? tmp->next->prev = now : 0;
  tmp->prev = tmp2;
  now->next = tmp->next;
  tmp->next = now;
  now->prev = tmp;
}

int     order(t_game *g)
{
  t_tetrimino        *now;

  now = g->first;
  if (now == NULL || g == NULL)
    return (0);
  while (now != NULL)
    {
      if (now->next == NULL)
	break;
      if (alpha_tri(now->name, now->next->name))
	{
	  swap_element(g, now, now->next);
	  now = g->first;
	}
      else
	now = now->next;
    }
  return (0);
}
